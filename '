package perms

// TODO:
// 1. 拆分 response 和他們動作 ex 設定鍵盤
// 2. 除存狀態

import (
	"1li/db/user"
	"1li/ent"
	"context"
	"fmt"
	"log"

	"github.com/PaulSonOfLars/gotgbot/v2"
	"github.com/PaulSonOfLars/gotgbot/v2/ext"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers/conversation"
)

const (
	ASK_USER  = "askUser"
	ASK_PERM  = "askPerm"
	ASK_VALUE = "askValue"
	SET_PERM = "setPerm"
)

var clearKeyboard = &gotgbot.SendMessageOpts{
	ReplyMarkup: &gotgbot.ReplyKeyboardRemove{
		RemoveKeyboard: true,
	},
}

var c = newClient()

var CMD = handlers.NewConversation(
	[]ext.Handler{handlers.NewCommand("perms", c.resUser)},
	map[string][]ext.Handler{
		USER:  {handlers.NewCommand("perms", c.resUser)},
		PERM:  {handlers.NewMessage(isUserShared, c.resPerm)},
		VALUE: {handlers.NewCallback(isPerms, c.resValue)},
	},
	&handlers.ConversationOpts{
		Exits:        []ext.Handler{handlers.NewCommand("exit", c.resExit)},
		StateStorage: conversation.NewInMemoryStorage(conversation.KeyStrategySenderAndChat),
		AllowReEntry: true,
	},
)

func (c *client) resUser(b *gotgbot.Bot, ctx *ext.Context) error {
	if err := askUser(b, ctx); err != nil {
		return fmt.Errorf("Fail to ask user: %w", err)
	}

	return handlers.NextConversationState(PERM)
}

// isuserShared checks if the message is a shared user request.
func isUserShared(msg *gotgbot.Message) bool {
	return msg.UsersShared != nil && msg.UsersShared.RequestId == msg.Chat.Id
}

func (c *client) resPerm(b *gotgbot.Bot, ctx *ext.Context) error {
	c.set(ctx, &userType{
		Username: ctx.Message.UsersShared.Users[0].Username,
		UserId:   ctx.Message.UsersShared.Users[0].UserId,
	})
	if err := askPerm(b, ctx); err != nil {
		return fmt.Errorf("Fail to ask perm: %w", err)
	}

	return handlers.NextConversationState(VALUE)
}

// isPerms check if the callback query can be handled by this handler.
func isPerms(cq *gotgbot.CallbackQuery) bool {
	return cq.Data == "customCode" || cq.Data == "admin" || cq.Data == "readAll"
}

func (c *client) resValue(b *gotgbot.Bot, ctx *ext.Context) error {
	perm := ctx.CallbackQuery.Data
	value, err := askValue(b, ctx, perm)
	if err != nil {
		return fmt.Errorf("Fail to ask value: %w", err)
	}

	u, ok := c.get(ctx)
	if !ok {
		return fmt.Errorf("User not found")
	}

	err = user.SetPerm(context.Background(), u.UserId, perm, value)
	if ent.IsNotFound(err) {
		ctx.EffectiveChat.SendMessage(b, "使用者不存在", nil)
		return handlers.EndConversation()
	} else if err != nil {
		return fmt.Errorf("Fail to set perm: %w", err)
	}

	log.Printf("set user permission: %s, perm: %s, value: %v\n", u.Username, perm, value)

	ctx.EffectiveChat.SendMessage(b, fmt.Sprintf("設定 %s: %v 給 %s", perm, value, u.Username), nil)

	// return handlers.NextConversationState(PERM)
	return handlers.EndConversation()
}

func (c *client) resExit(b *gotgbot.Bot, ctx *ext.Context) error {
	log.Println("Exit")
	_, err := ctx.EffectiveMessage.Reply(b, "已退出設定", clearKeyboard)
	if err != nil {
		return fmt.Errorf("Fail to send message: %w", err)
	}
	return handlers.EndConversation()
}

func askUser(b *gotgbot.Bot, ctx *ext.Context) error {
	f := false
	keyboard := gotgbot.ReplyKeyboardMarkup{
		Keyboard: [][]gotgbot.KeyboardButton{
			{
				{
					Text: "選擇目標使用者",
					RequestUsers: &gotgbot.KeyboardButtonRequestUsers{
						RequestId:       ctx.EffectiveChat.Id,
						UserIsBot:       &f,
						RequestUsername: true,
					},
				},
			},
		},
		ResizeKeyboard: true,
	}

	msgOpt := gotgbot.SendMessageOpts{
		ReplyMarkup: &keyboard,
	}

	_, err := ctx.EffectiveChat.SendMessage(b, "請選擇目標使用者", &msgOpt)
	if err != nil {
		return fmt.Errorf("Fail to send message: %w", err)
	}

	return nil
}

func askPerm(b *gotgbot.Bot, ctx *ext.Context) error {
	keyboard := gotgbot.InlineKeyboardMarkup{
		InlineKeyboard: [][]gotgbot.InlineKeyboardButton{
			{
				{
					Text:         "自訂短網址",
					CallbackData: "customCode",
				}, {
					Text:         "管理員",
					CallbackData: "admin",
				},
			}, {
				{
					Text:         "查看所有人的短資訊",
					CallbackData: "readAll",
				},
			},
		},
	}

	msgOpt := gotgbot.SendMessageOpts{
		ReplyMarkup: &keyboard,
	}

	// TODO: delete this message or clear keyboard without showing a message
	_, err := ctx.EffectiveChat.SendMessage(b, "claer keyboard", clearKeyboard)
	if err != nil {
		return fmt.Errorf("Fail to remove keyboard: %w", err)
	}

	_, err = ctx.EffectiveChat.SendMessage(b, "請選擇權限", &msgOpt)
	if err != nil {
		return fmt.Errorf("Fail to send message: %w", err)
	}

	return nil
}

func askValue(b *gotgbot.Bot, ctx *ext.Context, perm string) (bool, error) {
	_, err := b.AnswerCallbackQuery(ctx.CallbackQuery.Id, nil)
	if err != nil {
		return false, fmt.Errorf("Fail to answer callback query: %w", err)
	}

	keyboard := gotgbot.InlineKeyboardMarkup{
		InlineKeyboard: [][]gotgbot.InlineKeyboardButton{
			{
				{
					Text:         "是",
					CallbackData: "true",
				}, {
					Text:         "否",
					CallbackData: "false",
				},
			},{
				{
					Text:         "取消",
					CallbackData: "cancel",
				},
			},
		},
	}

	msgOpt := gotgbot.SendMessageOpts{
		ReplyMarkup: &keyboard,
	}

	_, err := ctx.EffectiveChat.SendMessage(b, fmt.Sprintf("是否要設定 %s 為 true?", perm), &msgOpt)
	if err != nil {
		return false, fmt.Errorf("Fail to send message: %w", err
	}

	return true, nil
}
